
<!DOCTYPE html>

<html>
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>View File | SasView Model Marketplace</title>
<link crossorigin="anonymous" href="https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu" rel="stylesheet"/>
<link charset="utf-8" href="/static/marketplace/style.css" rel="stylesheet">
<link href="/static/marketplace/ball.ico" rel="shortcut icon" type="image/x-icon"/>
<script charset="utf-8" src="/static/marketplace/jquery-2.2.4.min.js"></script>
<script crossorigin="anonymous" integrity="sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd" src="https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>
<link href="/static/marketplace/tomorrow-night.css" rel="stylesheet"/>
<script src="/static/marketplace/highlight.pack.js"></script>
<script type="text/javascript">
    hljs.initHighlightingOnLoad();
</script>
</link></head>
<body>
<nav class="navbar navbar-inverse navbar-fixed-top">
<div class="container container-fluid">
<div class="navbar-header">
<button aria-expanded="false" class="navbar-toggle collapsed" data-target="#navbar-collapse-1" data-toggle="collapse" type="button">
<span class="sr-only">Toggle navigation</span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</button>
<img src="/static/marketplace/logo.png"/><a class="navbar-brand" href="/">SasView Marketplace</a>
</div>
<div class="collapse navbar-collapse" id="navbar-collapse-1">
<ul class="nav navbar-nav navbar-right">
<li><a href="/accounts/login/"><span class="glyphicon glyphicon-log-in"></span> Log In </a></li>
</ul>
<form action="/search/" class="navbar-form navbar-left" method="get">
<div class="form-group">
<input class="form-control" name="query" placeholder="Search" type="text"/>
</div>
<button class="btn btn-default" type="submit"><span class="glyphicon glyphicon-search"></span></button>
</form>
</div><!-- /.navbar-collapse -->
</div>
</nav>
<div class="container">
<ol class="breadcrumb">
<li><a href="/">Categories</a></li>
<li><a href="/models/cylinder/">Cylinder</a></li>
<li><a href="/models/55/">Barbell</a></li>
<li><a href="/uploads/768">barbell.c</a></li>
</ol>
<h1>Barbell - barbell.c</h1>
<pre>
    <code>//barbell kernel - same as dumbbell
static double
_bell_kernel(double qab, double qc, double h, double radius_bell,
             double half_length)
{
    // translate a point in [-1,1] to a point in [lower,upper]
    const double upper = 1.0;
    const double lower = -h/radius_bell;
    const double zm = 0.5*(upper-lower);
    const double zb = 0.5*(upper+lower);

    // cos term in integral is:
    //    cos (q (R t - h + L/2) cos(alpha))
    // so turn it into:
    //    cos (m t + b)
    // where:
    //    m = q R cos(alpha)
    //    b = q(L/2-h) cos(alpha)
    const double m = radius_bell*qc; // cos argument slope
    const double b = (half_length+h)*qc; // cos argument intercept
    const double qab_r = radius_bell*qab; // Q*R*sin(theta)
    double total = 0.0;
    for (int i = 0; i &lt; GAUSS_N; i++){
        const double t = GAUSS_Z[i]*zm + zb;
        const double radical = 1.0 - t*t;
        const double bj = sas_2J1x_x(qab_r*sqrt(radical));
        const double Fq = cos(m*t + b) * radical * bj;
        total += GAUSS_W[i] * Fq;
    }
    // translate dx in [-1,1] to dx in [lower,upper]
    const double integral = total*zm;
    const double bell_fq = 2.0*M_PI*cube(radius_bell)*integral;
    return bell_fq;
}

static double
_fq(double qab, double qc, double h,
    double radius_bell, double radius, double half_length)
{
    const double bell_fq = _bell_kernel(qab, qc, h, radius_bell, half_length);
    const double bj = sas_2J1x_x(radius*qab);
    const double si = sas_sinx_x(half_length*qc);
    const double cyl_fq = 2.0*M_PI*radius*radius*half_length*bj*si;
    const double Aq = bell_fq + cyl_fq;
    return Aq;
}

static double
form_volume(double radius_bell,
    double radius,
    double length)
{
    // bell radius should never be less than radius when this is called
    const double h = sqrt(square(radius_bell) - square(radius));
    const double slice = M_PI*(square(radius_bell)*h - cube(h)/3.0);
    const double hemisphere = 2.0*M_PI/3.0*cube(radius_bell);
    const double rod = M_PI*square(radius)*length;
    // h &gt; 0 so slice is added to hemisphere
    return rod + 2.0*(hemisphere + slice);
}

static double
radius_from_excluded_volume(double radius_bell, double radius, double length)
{
    const double h = sqrt(square(radius_bell) - square(radius));
    const double length_tot = length + 2.0*(radius + h);
    // Use cylinder excluded volume with length' = length + caps and
    // radius' = bell radius since the bell is bigger than the cylinder.
    return 0.5*cbrt(0.75*radius_bell*(2.0*radius_bell*length_tot
           + (radius_bell + length_tot)*(M_PI*radius_bell + length_tot)));
}

static double
radius_from_volume(double radius_bell, double radius, double length)
{
    const double vol_barbell = form_volume(radius_bell,radius,length);
    return cbrt(vol_barbell/M_4PI_3);
}

static double
radius_from_totallength(double radius_bell, double radius, double length)
{
    const double h = sqrt(square(radius_bell) - square(radius));
    const double half_length = 0.5*length;
    return half_length + radius_bell + h;
}

static double
radius_effective(int mode, double radius_bell, double radius, double length)
{
    switch (mode) {
    default:
    case 1: // equivalent cylinder excluded volume
        return radius_from_excluded_volume(radius_bell, radius , length);
    case 2: // equivalent volume sphere
        return radius_from_volume(radius_bell, radius , length);
    case 3: // radius
        return radius;
    case 4: // half length
        return 0.5*length;
    case 5: // half total length
        return radius_from_totallength(radius_bell,radius,length);
    }
}

static void
Fq(double q,double *F1, double *F2, double sld, double solvent_sld,
    double radius_bell, double radius, double length)
{
    const double h = sqrt(square(radius_bell) - square(radius));
    const double half_length = 0.5*length;

    // translate a point in [-1,1] to a point in [0, pi/2]
    const double zm = M_PI_4;
    const double zb = M_PI_4;
    double total_F1 = 0.0;
    double total_F2 = 0.0;
    for (int i = 0; i &lt; GAUSS_N; i++){
        const double theta = GAUSS_Z[i]*zm + zb;
        double sin_theta, cos_theta; // slots to hold sincos function output
        SINCOS(theta, sin_theta, cos_theta);
        const double qab = q*sin_theta;
        const double qc = q*cos_theta;
        const double Aq = _fq(qab, qc, h, radius_bell, radius, half_length);
        // scale by sin_theta for spherical coord integration
        total_F1 += GAUSS_W[i] * Aq * sin_theta;
        total_F2 += GAUSS_W[i] * Aq * Aq * sin_theta;
    }
    // translate dx in [-1,1] to dx in [lower,upper]
    const double form_avg = total_F1 * zm;
    const double form_squared_avg = total_F2 * zm;

    //Contrast
    const double s = (sld - solvent_sld);
    *F1 = 1.0e-2 * s * form_avg;
    *F2 = 1.0e-4 * s * s * form_squared_avg;
}

static double
Iqac(double qab, double qc,
    double sld, double solvent_sld,
    double radius_bell, double radius, double length)
{
    const double h = sqrt(square(radius_bell) - square(radius));
    const double Aq = _fq(qab, qc, h, radius_bell, radius, 0.5*length);

    // Multiply by contrast^2 and convert to cm-1
    const double s = (sld - solvent_sld);
    return 1.0e-4 * square(s * Aq);
}
</code>
</pre>
<a class="btn btn-default" href="/models/55/">Back to Model</a>
<a class="btn btn-primary" href="/uploads/uploaded_models/barbell.c"><span class="glyphicon glyphicon-download"></span> Download</a>
</div>
</body>
</html>
