
<!DOCTYPE html>

<html>
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>View File | SasView Model Marketplace</title>
<link crossorigin="anonymous" href="https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu" rel="stylesheet"/>
<link charset="utf-8" href="/static/marketplace/style.css" rel="stylesheet">
<link href="/static/marketplace/ball.ico" rel="shortcut icon" type="image/x-icon"/>
<script charset="utf-8" src="/static/marketplace/jquery-2.2.4.min.js"></script>
<script crossorigin="anonymous" integrity="sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd" src="https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>
<link href="/static/marketplace/tomorrow-night.css" rel="stylesheet"/>
<script src="/static/marketplace/highlight.pack.js"></script>
<script type="text/javascript">
    hljs.initHighlightingOnLoad();
</script>
</link></head>
<body>
<nav class="navbar navbar-inverse navbar-fixed-top">
<div class="container container-fluid">
<div class="navbar-header">
<button aria-expanded="false" class="navbar-toggle collapsed" data-target="#navbar-collapse-1" data-toggle="collapse" type="button">
<span class="sr-only">Toggle navigation</span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</button>
<img src="/static/marketplace/logo.png"/><a class="navbar-brand" href="/">SasView Marketplace</a>
</div>
<div class="collapse navbar-collapse" id="navbar-collapse-1">
<ul class="nav navbar-nav navbar-right">
<li><a href="/accounts/login/"><span class="glyphicon glyphicon-log-in"></span> Log In </a></li>
</ul>
<form action="/search/" class="navbar-form navbar-left" method="get">
<div class="form-group">
<input class="form-control" name="query" placeholder="Search" type="text"/>
</div>
<button class="btn btn-default" type="submit"><span class="glyphicon glyphicon-search"></span></button>
</form>
</div><!-- /.navbar-collapse -->
</div>
</nav>
<div class="container">
<ol class="breadcrumb">
<li><a href="/">Categories</a></li>
<li><a href="/models/sphere/">Sphere</a></li>
<li><a href="/models/141/">Field-dependent magnetic SANS of misaligned magnetic moments in bulk ferromagnets</a></li>
<li><a href="/uploads/661">micromagnetic_misalignment_3D.c</a></li>
</ol>
<h1>Field-dependent magnetic SANS of misaligned magnetic moments in bulk ferromagnets - micromagnetic_misalignment_3D.c</h1>
<pre>
    <code>//Core-shell form factor for anisotropy field (Hkx, Hky and Hkz), Nuc and longitudinal magnetization Mz

static double
form_volume(double radius, double thickness)
{
 return M_4PI_3 * cube(radius + thickness);
}

static double
radius_effective(int mode, double radius, double thickness)
{
 switch (mode) {
    default:
      case 1: // outer radius
        return radius + thickness;
      case 2: // core radius
        return radius;
 }
}

static double fq(double q, double radius,
 double thickness, double core_sld, double shell_sld, double solvent_sld)
{
  const double form = core_shell_fq(q,
    radius,
    thickness,
    core_sld,
    shell_sld,
    solvent_sld);
  return form;
}

static double reduced_field(double q, double Ms, double Hi,
 double A)
{
  if( Hi &gt; 1.0e-6 ) 
    return Ms / (Hi + 2.0 * A * 4.0 * M_PI / Ms * q * q * 10.0);
    //q in 10e10 m-1, A in 10e-12 J/m, mu0 in 1e-7 
  else 
    return Ms / (1.0e-6 + 2.0 * A * 4.0 * M_PI / Ms * q * q * 10.0); 

 }

static double DMI_length(double Ms, double D, double q)
{
  return 2.0 * D * 4.0 * M_PI / Ms / Ms * q; 
  //q in 10e10 m-1, A in 10e-3 J/m^2, mu0 in 4 M_PI 1e-7 
}

//Mz is defined as the longitudinal magnetisation component along the magnetic field.
//In the approach to saturation this component is (almost) constant with magnetic 
//field and simplfy reflects the nanoscale variations in the saturation magnetisation
//value in the sample. The misalignment of the magnetisation due to perturbing
//magnetic anisotropy or dipolar magnetic fields in the sample enter Mx and My,
//the two transversal magnetisation components, reacting to a magnetic field.
//The micromagnetic solution for the magnetisation are from Michels et al. PRB 94, 054424 (2016).

static double fqMxreal( double x,double y, double z, double Mz, double Hkx, double Hky, double Hi, double Ms, double A, double D)
{
  const double q=MAG_VEC(x, y, z);
  const double f = reduced_field(q, Ms, Hi, A)*(Hkx*(1.0+reduced_field(q, Ms, Hi, A)*y*y/q/q)-Ms*Mz*x*z/q/q*(1.0+reduced_field(q, Ms, Hi, A)*DMI_length(Ms, D, q)*DMI_length(Ms, D, q))-Hky*reduced_field(q, Ms, Hi, A)*x*y/q/q)/(1.0+reduced_field(q, Ms, Hi, A)*(x*x+y*y)/q/q -square(reduced_field(q, Ms, Hi, A)*DMI_length(Ms, D,z)));
  return f;
}

static double fqMximag( double x, double y, double z, double Mz, double Hkx, double Hky, double Hi, double Ms, double A, double D)
{
  const double q=MAG_VEC(x, y, z);   
  const double f = -reduced_field(q, Ms, Hi, A)*(Ms*Mz*(1.0+reduced_field(q, Ms, Hi, A))*DMI_length(Ms, D,y)+Hky*reduced_field(q, Ms, Hi, A)*DMI_length(Ms, D,z))/(1.0+reduced_field(q, Ms, Hi, A)*(x*x+y*y)/q/q -square(reduced_field(q, Ms, Hi, A)*DMI_length(Ms, D,z)));
  return f;
}

static double fqMyreal( double x, double y, double z, double Mz, double Hkx, double Hky, double Hi, double Ms, double A, double D)
{
  const double q=MAG_VEC(x, y, z);   
  const double f = reduced_field(q, Ms, Hi, A)*(Hky*(1.0+reduced_field(q, Ms, Hi, A)*x*x/q/q)-Ms*Mz*y*z/q/q*(1.0+reduced_field(q, Ms, Hi, A)*DMI_length(Ms, D,q)*DMI_length(Ms, D,q))-Hkx*reduced_field(q, Ms, Hi, A)*x*y/q/q)/(1.0+reduced_field(q, Ms, Hi, A)*(x*x+y*y)/q/q -square(reduced_field(q, Ms, Hi, A)*DMI_length(Ms, D,z)));
  return f;
}

static double fqMyimag( double x, double y, double z, double Mz, double Hkx, double Hky, double Hi, double Ms, double A, double D)
{
  const double q=MAG_VEC(x, y, z);  
  const double f = reduced_field(q, Ms, Hi, A)*(Ms*Mz*(1.0+reduced_field(q, Ms, Hi, A))*DMI_length(Ms, D,x)-Hkx*reduced_field(q, Ms, Hi, A)*DMI_length(Ms, D,z))/(1.0+reduced_field(q, Ms, Hi, A)*(x*x+y*y)/q/q -square(reduced_field(q, Ms, Hi, A)*DMI_length(Ms, D,z)));
  return f;
}

//calculate 2D from _fq
static double
Iqxy(double qx, double qy, double radius, double thickness,double core_nuc, double shell_nuc, double solvent_nuc, double core_Ms, double shell_Ms, double solvent_Ms, double core_hk,  double Hi, double Ms, double A, double D,  double up_i, double up_f, double alpha, double beta)
{
  const double q=MAG_VEC(qx, qy, 0);
  if (q &gt; 1.0e-16 ) {
    const double cos_theta=qx/q;
    const double sin_theta=qy/q;

    double qrot[3];
    set_scatvec(qrot,q,cos_theta, sin_theta, alpha, beta);

    double weights[8];  // 0=dd.real, 1=dd.imag, 2=uu.real, 3=uu.imag,  4=du.real, 6=du.imag,  7=ud.real, 5=ud.imag
    set_weights(up_i, up_f, weights);
   
    double mz=fq(q, radius, thickness, core_Ms, shell_Ms, solvent_Ms);
    double nuc=fq(q, radius, thickness, core_nuc, shell_nuc, solvent_nuc);

    double cos_gamma, sin_gamma;
    double sld[8];
    double sld_res[8];
    //loop over random anisotropy axis with isotropic orientation gamma for Hkx and Hky
    //To be modified for textured material see also Weissmueller et al. PRB 63, 214414 (2001)
    double total_F2 = 0.0;
    double total_F2_res = 0.0;   
    for (int i=0; i&lt;GAUSS_N ;i++) {
      const double gamma = M_PI * (GAUSS_Z[i] + 1.0); // 0 .. 2 pi
      SINCOS(gamma, sin_gamma, cos_gamma);	
      
      double Hkx= fq(q, radius, thickness, core_hk, 0, 0)*sin_gamma;//Only the core of the defect/particle in the matrix has an effective anisotropy (for simplicity), for the effect of different, more complex spatial profile of the anisotropy see Michels PRB 82, 024433 (2010)
      double Hky= fq(q, radius, thickness, core_hk, 0, 0)*cos_gamma;

      double mxreal=fqMxreal(qrot[0], qrot[1], qrot[2], mz, Hkx, Hky, Hi, Ms, A, D);
      double mximag=fqMximag(qrot[0], qrot[1], qrot[2], mz, Hkx, Hky, Hi, Ms, A, D);
      double myreal=fqMyreal(qrot[0], qrot[1], qrot[2], mz, Hkx, Hky, Hi, Ms, A, D);
      double myimag=fqMyimag(qrot[0], qrot[1], qrot[2], mz, Hkx, Hky, Hi, Ms, A, D);

      mag_sld(qrot[0], qrot[1], qrot[2], mxreal, mximag, myreal, myimag, mz, 0, nuc, sld);
      mag_sld(qrot[0], qrot[1], qrot[2], 0, 0, 0, 0, mz, 0, nuc, sld_res);//Magnetic SLD at saturation
      double form = 0.0;
      double form_res = 0.0;      

      for (unsigned int xs=0; xs&lt;8; xs++) {
        if (weights[xs] &gt; 1.0e-8) {
          // Since the cross section weight is significant, set the slds
          // to the effective slds for this cross section, call the
          // kernel, and add according to weight.
          // loop over uu, ud real, du real, dd, ud imag, du imag 
          form += weights[xs]*sld[xs]*sld[xs];
          form_res += weights[xs]*sld_res[xs]*sld_res[xs];
        }
      }
      total_F2 += GAUSS_W[i] * form ;
      total_F2_res += GAUSS_W[i] * form_res ;     
    }
  return 0.5*1.0e-4*(total_F2-total_F2_res);
  }
}


//calculate 1D by averaging over theta
//TODO: choose orientation and sector width for averaging
// 2D to 1D
static double
Iq(double q, double radius, double thickness,double core_nuc, double shell_nuc, double solvent_nuc, double core_Ms, double shell_Ms, double solvent_Ms, double core_hk, double Hi, double Ms, double A, double D,  double up_i, double up_f, double alpha, double beta)
{
  // slots to hold sincos function output of the orientation on the detector plane
  double sin_theta, cos_theta; 
  double total_F1D = 0.0;
  double total_F1D_res = 0.0;   
  for (int j=0; j&lt;GAUSS_N ;j++) {

    const double theta = M_PI * (GAUSS_Z[j] + 1.0); // 0 .. 2 pi
    SINCOS(theta, sin_theta, cos_theta);

    double qrot[3];
    set_scatvec(qrot,q,cos_theta, sin_theta, alpha, beta);
    // 0=dd.real, 1=dd.imag, 2=uu.real, 3=uu.imag,  4=du.real, 5=du.imag,  6=ud.real, 7=ud.imag
    double weights[8];  
    set_weights(up_i, up_f, weights);
   
    double mz=fq(q, radius, thickness, core_Ms, shell_Ms, solvent_Ms);
    double nuc=fq(q, radius, thickness, core_nuc, shell_nuc, solvent_nuc);

    double cos_gamma, sin_gamma;
    double sld[8];
    double sld_res[8];

    //loop over random anisotropy axis with isotropic orientation gamma for Hkx and Hky
    //To be modified for textured material see also Weissmueller et al. PRB 63, 214414 (2001)
    double total_F2 = 0.0;
    double total_F2_res = 0.0;   
    for (int i=0; i&lt;GAUSS_N ;i++) {
      const double gamma = M_PI * (GAUSS_Z[i] + 1.0); // 0 .. 2 pi
      SINCOS(gamma, sin_gamma, cos_gamma);	
      
      double Hkx= fq(q, radius, thickness, core_hk, 0, 0)*sin_gamma;//Only the core of the defect/particle in the matrix has an effective anisotropy (for simplicity), for the effect of different, more complex spatial profile of the anisotropy see Michels PRB 82, 024433 (2010)
      double Hky= fq(q, radius, thickness, core_hk, 0, 0)*cos_gamma;

      double mxreal=fqMxreal(qrot[0], qrot[1], qrot[2], mz, Hkx, Hky, Hi, Ms, A, D);
      double mximag=fqMximag(qrot[0], qrot[1], qrot[2], mz, Hkx, Hky, Hi, Ms, A, D);
      double myreal=fqMyreal(qrot[0], qrot[1], qrot[2], mz, Hkx, Hky, Hi, Ms, A, D);
      double myimag=fqMyimag(qrot[0], qrot[1], qrot[2], mz, Hkx, Hky, Hi, Ms, A, D);

      mag_sld(qrot[0], qrot[1], qrot[2], mxreal, mximag, myreal, myimag, mz, 0, nuc, sld);
      mag_sld(qrot[0], qrot[1], qrot[2], 0, 0, 0, 0, mz, 0, nuc, sld_res);//Magnetic SLD at saturation
      double form = 0.0;
      double form_res = 0.0;     
      for (unsigned int xs=0; xs&lt;8; xs++) {
        if (weights[xs] &gt; 1.0e-8 ) {
          // Since the cross section weight is significant, set the slds
          // to the effective slds for this cross section, call the
          // kernel, and add according to weight.
          // loop over uu, ud real, du real, dd, ud imag, du imag 
          form += weights[xs]*sld[xs]*sld[xs];
          form_res += weights[xs]*sld_res[xs]*sld_res[xs];        
        }
      }
      total_F2 += GAUSS_W[i] * form ;
      total_F2_res += GAUSS_W[i] * form_res ;    
    }
    total_F1D += GAUSS_W[j] * total_F2 ;
    total_F1D_res += GAUSS_W[j] * total_F2_res ; 
  }
  //convert from [1e-12 A-1] to [cm-1]
  return 0.25*1.0e-4*(total_F1D-total_F1D_res);
}






</code>
</pre>
<a class="btn btn-default" href="/models/141/">Back to Model</a>
<a class="btn btn-primary" href="/uploads/uploaded_models/micromagnetic_misalignment_3D.c"><span class="glyphicon glyphicon-download"></span> Download</a>
</div>
</body>
</html>
